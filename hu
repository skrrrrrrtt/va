-- MERGED PLS DONATE SCRIPT
-- Uses your original features + improved server-hop, remotes require, and fallback booth-claiming
-- Based on your provided script pieces (requirex + server hop logic) for robustness. (See cc.txt)

repeat task.wait() until game:IsLoaded()

----------------------------------------------------------------------
-- CONFIG (edit as you want)
----------------------------------------------------------------------
_G.goalAmount = 1000
_G.textHex = "#32CD32"
_G.font = Enum.Font.FredokaOne

_G.minPlayersBeforeHop = 5        -- hop when players <= this after initial wait
_G.initialHopWait = 15            -- seconds to wait before first server-check
_G.serverSearchPages = 8          -- how many server pages to scan when hopping
_G.begInterval = 45               -- seconds between begging messages
_G.begMessages = {
    "please donate if you can",
    "any small donation helps",
    "trying to reach my goal",
    "even 1 robux helps",
    "saving up for my booth",
    "grinding for my goal",
    "trying to upgrade my stand",
    "any support means a lot"
}
_G.boardUpdateInterval = 8        -- fallback periodic board update

----------------------------------------------------------------------
-- LOG helper
----------------------------------------------------------------------
local function log(msg)
    print("[PLSD] >> " .. tostring(msg))
end

log("Script starting...")

----------------------------------------------------------------------
-- SERVICES + LOCALS
----------------------------------------------------------------------
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local VirtualUser = game:GetService("VirtualUser")
local Workspace = workspace

----------------------------------------------------------------------
-- Anti-AFK (VirtualUser)
----------------------------------------------------------------------
LocalPlayer.Idled:Connect(function()
    log("Anti-AFK triggered.")
    VirtualUser:CaptureController()
    VirtualUser:ClickButton2(Vector2.new())
end)

----------------------------------------------------------------------
-- WAIT FOR UI & CHARACTER
----------------------------------------------------------------------
log("Waiting for Map UI and character HRP...")
local pg = LocalPlayer:WaitForChild("PlayerGui")
repeat task.wait() until pg:FindFirstChild("MapUIContainer") and pg.MapUIContainer:FindFirstChild("MapUI")
local BoothUI = pg.MapUIContainer.MapUI:WaitForChild("BoothUI")
repeat task.wait() until LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
local raisedStat = LocalPlayer:WaitForChild("leaderstats"):WaitForChild("Raised")

----------------------------------------------------------------------
-- requirex (robust require for Remotes module) (adapted from your script)
----------------------------------------------------------------------
local function requirex(scrip)
    if not scrip or not scrip:IsA or not scrip:IsA('ModuleScript') then
        log("requirex: invalid module; aborting require.")
        return nil
    end

    local mscript
    repeat
        task.wait(0.1)
        local suc, err = pcall(function() mscript = require(scrip) end)
        if not suc then
            log("requirex: require failed: " .. tostring(err))
        end
    until mscript
    return mscript
end

-- safe get Remotes module (handles if it's a ModuleScript in ReplicatedStorage.Remotes)
local RemotesModule
if ReplicatedStorage:FindFirstChild("Remotes") then
    RemotesModule = requirex(ReplicatedStorage.Remotes)
else
    -- fallback: try requiring by name if different structure
    pcall(function() RemotesModule = requirex(ReplicatedStorage:FindFirstChild("Remotes") or ReplicatedStorage:FindFirstChildOfClass("ModuleScript")) end)
end

if not RemotesModule then
    log("WARNING: couldn't load Remotes module. Some actions may fail.")
end

----------------------------------------------------------------------
-- UTIL: hex -> Color3
----------------------------------------------------------------------
local function hexToColor3(hex)
    if not hex then return Color3.new(1,1,1) end
    hex = tostring(hex):gsub("#","")
    if #hex ~= 6 then return Color3.new(1,1,1) end
    local r = tonumber("0x"..hex:sub(1,2)) or 255
    local g = tonumber("0x"..hex:sub(3,4)) or 255
    local b = tonumber("0x"..hex:sub(5,6)) or 255
    return Color3.fromRGB(r,g,b)
end
local textColor = hexToColor3(_G.textHex)

----------------------------------------------------------------------
-- SERVER HOP: Search servers pages and pick a good non-full server
-- adapted from the logic in the script you provided (Search / findHighest / tp)
----------------------------------------------------------------------
local function searchServers(pages)
    log("Searching servers (pages = " .. tostring(pages) .. ")")
    local all = {}
    local url = "https://games.roblox.com/v1/games/" .. tostring(game.PlaceId) .. "/servers/Public?sortOrder=Asc&limit=100"
    local cursor = nil
    for i = 1, pages do
        local q = url
        if cursor then q = url .. "&cursor=" .. tostring(cursor) end
        local ok, body = pcall(function() return game:HttpGet(q) end)
        if not ok or not body then
            log("searchServers: http get failed on page " .. i)
            break
        end

        local suc, data = pcall(function() return HttpService:JSONDecode(body) end)
        if not suc or not data or not data.data then
            log("searchServers: decode failed on page " .. i)
            break
        end

        for _, s in ipairs(data.data) do
            if tostring(s.id) ~= tostring(game.JobId) and tonumber(s.playing) and tonumber(s.maxPlayers) then
                -- only consider servers that are not full
                if tonumber(s.playing) < tonumber(s.maxPlayers) then
                    table.insert(all, {id = s.id, players = tonumber(s.playing), max = tonumber(s.maxPlayers)})
                end
            end
        end

        if data.nextPageCursor and data.nextPageCursor ~= "null" then
            cursor = data.nextPageCursor
        else
            break
        end
    end
    return all
end

local function findBestServer(servers)
    local best = nil
    for _, s in ipairs(servers) do
        -- prefer servers with higher players but not almost full (avoid servers that will fill instantly)
        if not best or (s.players > best.players and s.players < (s.max - 2)) then
            best = s
        end
    end
    return best
end

local function doSmartHop()
    log("doSmartHop: searching for candidate servers...")
    local servers = searchServers(_G.serverSearchPages)
    if #servers == 0 then
        log("doSmartHop: no candidate servers found, fallback teleport.")
        TeleportService:Teleport(game.PlaceId)
        return
    end
    local best = findBestServer(servers)
    if best then
        log("doSmartHop: teleporting to server id " .. tostring(best.id) .. " with " .. tostring(best.players) .. " players.")
        TeleportService:TeleportToPlaceInstance(game.PlaceId, best.id)
    else
        log("doSmartHop: no 'best' server found, teleporting to random candidate.")
        local s = servers[math.random(1, #servers)]
        TeleportService:TeleportToPlaceInstance(game.PlaceId, s.id)
    end
end

-- Kick off safe server-check loop after initial wait
task.spawn(function()
    log("Server-check init: waiting " .. tostring(_G.initialHopWait) .. "s so players can populate.")
    task.wait(_G.initialHopWait)
    while task.wait(20) do
        local count = #Players:GetPlayers()
        log("Server-check: current players = " .. tostring(count))
        if count <= _G.minPlayersBeforeHop then
            log("Server-check: low player count => hopping")
            doSmartHop()
            return -- hopping; stop loop
        else
            log("Server-check: server OK, no hop.")
        end
    end
end)

----------------------------------------------------------------------
-- FIND UNCLAIMED BOOTHS (robustly using BoothUI + distance checking)
-- uses mainCheckPosition heuristic from your script
----------------------------------------------------------------------
local mainCheckPosition = Vector3.new(165.161, 0, 311.636) -- kept from original script heuristics
local function findUnclaimedNearby(maxDistance)
    maxDistance = maxDistance or 120
    local list = {}
    for _, ui in ipairs(BoothUI:GetChildren()) do
        if ui:FindFirstChild("Details") and ui.Details:FindFirstChild("Owner") then
            local ownerText = tostring(ui.Details.Owner.Text):lower()
            if ownerText:find("unclaim") then
                local slot = tonumber(tostring(ui.Name):match("%d+"))
                if slot then
                    for _, part in ipairs(Workspace:WaitForChild("BoothInteractions"):GetChildren()) do
                        if part:GetAttribute("BoothSlot") == slot then
                            local flatDistance = (part.Position * Vector3.new(1,0,1) - mainCheckPosition).Magnitude
                            if flatDistance < maxDistance then
                                table.insert(list, slot)
                                log("findUnclaimedNearby: candidate slot " .. tostring(slot) .. " (dist="..tostring(math.floor(flatDistance))..")")
                            end
                            break
                        end
                    end
                end
            end
        end
    end
    return list
end

----------------------------------------------------------------------
-- CLAIMING: try remote ClaimBooth first, fallback to proximity prompt (from the other script)
----------------------------------------------------------------------
local function fireClaimProximity(slot)
    for _, part in ipairs(Workspace.BoothInteractions:GetChildren()) do
        if part:GetAttribute("BoothSlot") == slot then
            local prompt = part:FindFirstChild("Claim") or part:FindFirstChildOfClass("ProximityPrompt")
            if prompt then
                log("fireClaimProximity: firing proximity prompt for slot " .. tostring(slot))
                pcall(function() fireproximityprompt(prompt, 0) end)
                return true
            end
        end
    end
    return false
end

local function tryClaimSlot(slot)
    log("tryClaimSlot: attempting remote claim for slot " .. tostring(slot))
    if RemotesModule and RemotesModule.Event then
        local ok, err = pcall(function()
            RemotesModule.Event("ClaimBooth"):InvokeServer(slot)
        end)
        if ok then
            log("tryClaimSlot: remote InvokeServer returned (may be claimed).")
            -- verify UI ownership quickly
            local ourUI = BoothUI:FindFirstChild("BoothUI"..tostring(slot))
            if ourUI and ourUI.Details and ourUI.Details.Owner and tostring(ourUI.Details.Owner.Text):lower():find(LocalPlayer.DisplayName:lower()) then
                log("tryClaimSlot: verified ownership via UI for slot " .. tostring(slot))
                return true
            end
            -- remote claimed but UI not updated yet - wait briefly and check again
            task.wait(1)
            if ourUI and ourUI.Details and ourUI.Details.Owner and tostring(ourUI.Details.Owner.Text):lower():find(LocalPlayer.DisplayName:lower()) then
                log("tryClaimSlot: verified ownership after 1s for slot " .. tostring(slot))
                return true
            end
            log("tryClaimSlot: remote claim didn't reflect on UI. Falling back to proximity prompt.")
        else
            log("tryClaimSlot: remote claim pcall failed: " .. tostring(err))
        end
    else
        log("tryClaimSlot: RemotesModule missing, can't InvokeServer.")
    end

    -- fallback: proximity prompt
    local okPrompt = fireClaimProximity(slot)
    if okPrompt then
        log("tryClaimSlot: fired proximity prompt for slot " .. tostring(slot) .. ".")
        task.wait(0.8)
        return true
    end

    log("tryClaimSlot: failed to claim slot " .. tostring(slot))
    return false
end

----------------------------------------------------------------------
-- UPDATE BOOTH TEXT (SetCustomization table form)
----------------------------------------------------------------------
local function updateBoothText()
    local raised = raisedStat.Value or 0
    local text = string.format("<b>GOAL %s / %s</b>", tostring(raised), tostring(_G.goalAmount))
    log("updateBoothText: " .. text)
    if RemotesModule and RemotesModule.Event then
        pcall(function()
            RemotesModule.Event("SetCustomization"):FireServer({
                text = text,
                richText = true,
                textFont = _G.font,
                textColor = textColor,
                strokeColor = Color3.new(0,0,0),
                strokeOpacity = 0,
                buttonStrokeColor = Color3.new(0,0,0),
                buttonTextColor = Color3.new(1,1,1),
                buttonColor = Color3.fromRGB(98,255,0),
                buttonHoverColor = Color3.fromRGB(98,255,0),
                buttonLayout = ""
            }, "booth")
        end)
    else
        log("updateBoothText: RemotesModule not available.")
    end
end

----------------------------------------------------------------------
-- CLAIM FLOW: find candidate booths, try to claim them in order, then teleport/dance and update text
----------------------------------------------------------------------
local function claimFlow()
    log("claimFlow: starting flow to find & claim booth")
    local unclaimed = findUnclaimedNearby(92)
    if #unclaimed == 0 then
        log("claimFlow: no nearby unclaimed booths, expanding search.")
        unclaimed = findUnclaimedNearby(9999) -- fallback: include all
    end
    if #unclaimed == 0 then
        log("claimFlow: still no unclaimed booths found.")
        return false
    end

    for i, slot in ipairs(unclaimed) do
        log("claimFlow: trying slot " .. tostring(slot) .. " (".. tostring(i) .."/".. tostring(#unclaimed) ..")")
        local ok = tryClaimSlot(slot)
        if ok then
            -- teleport to the matching part
            for _, part in ipairs(Workspace.BoothInteractions:GetChildren()) do
                if part:GetAttribute("BoothSlot") == slot and part:IsA("BasePart") then
                    log("claimFlow: teleporting to booth slot " .. tostring(slot))
                    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
                    local hrp = char:WaitForChild("HumanoidRootPart")
                    hrp.CFrame = part.CFrame * CFrame.new(3, 3, 3)
                    task.wait(0.2)
                    hrp.CFrame = CFrame.new(hrp.Position) * CFrame.Angles(0, 0, 0) -- face forward

                    -- start dance quickly
                    pcall(function()
                        local hum = char:FindFirstChildOfClass("Humanoid")
                        if hum and char:FindFirstChild("Animate") then
                            pcall(function() hum:LoadAnimation(char.Animate.dance.Animation1):Play() end)
                        end
                    end)

                    updateBoothText()
                    log("claimFlow: success on slot " .. tostring(slot))
                    return true
                end
            end
            -- if no part found, still return success (we invoked remote)
            return true
        else
            log("claimFlow: failed to claim slot " .. tostring(slot) .. ", trying next.")
        end
    end

    log("claimFlow: exhausted candidate slots without success.")
    return false
end

-- initial claim attempt and on respawn
task.spawn(function()
    task.wait(1.5)
    claimFlow()
end)
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(2)
    claimFlow()
end)

----------------------------------------------------------------------
-- DANCE ROTATION (1 -> 2 -> 3 every 60s) and initial dance when teleport
----------------------------------------------------------------------
task.spawn(function()
    log("Starting dance rotation loop")
    while task.wait() do
        local char = LocalPlayer.Character
        if char and char:FindFirstChildOfClass("Humanoid") and char:FindFirstChild("Animate") then
            log("Dance cycle: playing dance 1")
            pcall(function() char.Humanoid:LoadAnimation(char.Animate.dance.Animation1):Play() end)
        end
        task.wait(60)
        if char and char:FindFirstChildOfClass("Humanoid") and char:FindFirstChild("Animate") then
            log("Dance cycle: playing dance 2")
            pcall(function() char.Humanoid:LoadAnimation(char.Animate.dance2.Animation2):Play() end)
        end
        task.wait(60)
        if char and char:FindFirstChildOfClass("Humanoid") and char:FindFirstChild("Animate") then
            log("Dance cycle: playing dance 3")
            pcall(function() char.Humanoid:LoadAnimation(char.Animate.dance3.Animation3):Play() end)
        end
        task.wait(60)
    end
end)

----------------------------------------------------------------------
-- AUTO-JUMP ON DONATION (and update booth text)
----------------------------------------------------------------------
do
    local last = tonumber(tostring(raisedStat.Value)) or 0
    raisedStat.Changed:Connect(function(new)
        local newVal = tonumber(tostring(new)) or 0
        if newVal > last then
            log("Donation detected: " .. tostring(last) .. " -> " .. tostring(newVal) .. " ; jumping")
            task.spawn(function()
                local char = LocalPlayer.Character
                if char then
                    local hum = char:FindFirstChildOfClass("Humanoid")
                    if hum then
                        for i = 1, 3 do
                            hum:ChangeState(Enum.HumanoidStateType.Jumping)
                            task.wait(0.35)
                        end
                    end
                end
            end)
            updateBoothText()
        end
        last = newVal
    end)
end

----------------------------------------------------------------------
-- AUTO-BEGGING (no emojis)
----------------------------------------------------------------------
local function sayChat(msg)
    if ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents") and ReplicatedStorage.DefaultChatSystemChatEvents:FindFirstChild("SayMessageRequest") then
        pcall(function()
            ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(msg, "All")
        end)
    else
        log("sayChat: chat remote missing")
    end
end

task.spawn(function()
    log("Starting auto-begging loop (no emojis)")
    while task.wait(_G.begInterval) do
        local msg = _G.begMessages[math.random(1, #_G.begMessages)]
        log("Auto-begging message: " .. msg)
        sayChat(msg)
    end
end)

----------------------------------------------------------------------
-- PERIODIC BOARD UPDATE (in case UI is slow)
----------------------------------------------------------------------
task.spawn(function()
    while task.wait(_G.boardUpdateInterval) do
        pcall(function() updateBoothText() end)
    end
end)

log("Merged script loaded successfully.")
