repeat task.wait() until game:IsLoaded()

local function log(msg)
    print("[PLSD] >> " .. tostring(msg))
end

log("Starting final fixed script...")

-- SETTINGS
_G.goalAmount = 1000
_G.begInterval = 45
_G.begMessages = {
    "please donate if you can",
    "any small donation helps",
    "trying to reach my goal",
    "even 1 robux helps",
    "saving up for my booth",
    "grinding my goal",
    "trying to upgrade my stand",
    "any support means a lot"
}

_G.minPlayersBeforeHop = 5
_G.serverSearchPages = 8
_G.initialHopWait = 15
_G.boardUpdateInterval = 8

-- SERVICES
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local Workspace = workspace
local VirtualUser = game:GetService("VirtualUser")
local TextChatService = pcall(function() return game:GetService("TextChatService") end) and game:GetService("TextChatService") or nil

-- ANTI-AFK
LocalPlayer.Idled:Connect(function()
    log("Anti-AFK triggered")
    VirtualUser:CaptureController()
    VirtualUser:ClickButton2(Vector2.new())
end)

-- WAIT FOR UI & CHAR
log("Waiting for Map UI and character...")
local pg = LocalPlayer:WaitForChild("PlayerGui")
repeat task.wait() until pg:FindFirstChild("MapUIContainer")
local BoothUI = pg.MapUIContainer.MapUI:WaitForChild("BoothUI")
repeat task.wait() until LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
local raisedStat = LocalPlayer:WaitForChild("leaderstats"):WaitForChild("Raised")
log("UI and character ready")

-- SAFE REQUIRE helper
local function requirex(module)
    local result
    repeat
        local ok, res = pcall(require, module)
        if ok then result = res end
        task.wait(0.05)
    until result
    return result
end

-- try load Remotes module safely
local RemotesModule = nil
if ReplicatedStorage:FindFirstChild("Remotes") then
    RemotesModule = requirex(ReplicatedStorage.Remotes)
    log("Loaded Remotes module")
else
    log("Remotes module not found in ReplicatedStorage")
end

-- UTIL: hex -> Color3 (safe)
local function hexToColor3(hex)
    if not hex then return Color3.fromRGB(255,255,255) end
    hex = tostring(hex):gsub("#","")
    if #hex ~= 6 then return Color3.fromRGB(255,255,255) end
    local r = tonumber("0x"..hex:sub(1,2)) or 255
    local g = tonumber("0x"..hex:sub(3,4)) or 255
    local b = tonumber("0x"..hex:sub(5,6)) or 255
    return Color3.fromRGB(r,g,b)
end
local textColor = hexToColor3("#32CD32")

----------------------------------------------------------------------
-- SMART SERVER HOP (robust)
----------------------------------------------------------------------
local function searchServers(pages)
    log("Searching servers (pages="..tostring(pages)..")")
    local all = {}
    local cursor = nil
    local baseUrl = "https://games.roblox.com/v1/games/"..tostring(game.PlaceId).."/servers/Public?sortOrder=Asc&limit=100"
    for i = 1, pages do
        local url = cursor and (baseUrl .. "&cursor=" .. cursor) or baseUrl
        local ok, body = pcall(game.HttpGet, game, url)
        if not ok or not body then
            log("searchServers: HTTP fetch failed page "..i)
            break
        end
        local suc, data = pcall(function() return HttpService:JSONDecode(body) end)
        if not suc or not data or not data.data then
            log("searchServers: decode failed page "..i)
            break
        end
        for _, s in ipairs(data.data) do
            if tostring(s.id) ~= tostring(game.JobId) and tonumber(s.playing) and tonumber(s.maxPlayers) then
                if tonumber(s.playing) < tonumber(s.maxPlayers) then
                    table.insert(all, {id = s.id, players = tonumber(s.playing), max = tonumber(s.maxPlayers)})
                end
            end
        end
        if data.nextPageCursor and data.nextPageCursor ~= "null" then cursor = data.nextPageCursor else break end
    end
    return all
end

local function pickBestServer(list)
    local best = nil
    for _, s in ipairs(list) do
        if not best or (s.players > best.players and s.players < (s.max - 2)) then
            best = s
        end
    end
    return best
end

local function doSmartHop()
    log("doSmartHop: searching for candidate servers...")
    local servers = searchServers(_G.serverSearchPages)
    if #servers == 0 then
        log("doSmartHop: no candidates, fallback teleport")
        TeleportService:Teleport(game.PlaceId)
        return
    end
    local best = pickBestServer(servers)
    if best then
        log("doSmartHop: teleporting to " .. tostring(best.id) .. " ("..tostring(best.players).." players)")
        TeleportService:TeleportToPlaceInstance(game.PlaceId, best.id)
    else
        local s = servers[math.random(1,#servers)]
        log("doSmartHop: teleporting to random candidate " .. tostring(s.id))
        TeleportService:TeleportToPlaceInstance(game.PlaceId, s.id)
    end
end

task.spawn(function()
    log("Waiting " .. tostring(_G.initialHopWait) .. "s before server-check")
    task.wait(_G.initialHopWait)
    while task.wait(20) do
        local count = #Players:GetPlayers()
        log("Server player count: " .. tostring(count))
        if count <= _G.minPlayersBeforeHop then
            log("Low players -> hopping")
            doSmartHop()
            return
        else
            log("Server OK, no hop")
        end
    end
end)

----------------------------------------------------------------------
-- BOOTH: safe finder (skip non-booth children)
----------------------------------------------------------------------
local mainCheckPosition = Vector3.new(165.161, 0, 311.636)

local function isRealBooth(part)
    if not part then return false end
    if type(part.GetAttribute) ~= "function" then return false end
    local val = part:GetAttribute("BoothSlot")
    return typeof(val) == "number"
end

local function findUnclaimedNearby(radius)
    local list = {}
    for _, ui in ipairs(BoothUI:GetChildren()) do
        if ui and ui:FindFirstChild("Details") and ui.Details:FindFirstChild("Owner") then
            local ownerText = tostring(ui.Details.Owner.Text):lower()
            if ownerText:find("unclaim") then
                local slot = tonumber(tostring(ui.Name):match("%d+"))
                if slot then
                    for _, booth in ipairs(Workspace:WaitForChild("BoothInteractions"):GetChildren()) do
                        if isRealBooth(booth) and booth:GetAttribute("BoothSlot") == slot then
                            local pos = (booth.Position or (booth.CFrame and booth.CFrame.Position) or Vector3.new())
                            local dist = (pos * Vector3.new(1,0,1) - mainCheckPosition).Magnitude
                            if dist < radius then
                                table.insert(list, slot)
                                log("findUnclaimedNearby: candidate slot "..tostring(slot).." dist="..tostring(math.floor(dist)))
                            end
                            break
                        end
                    end
                end
            end
        end
    end
    return list
end

----------------------------------------------------------------------
-- CLAIM: remote then proximity fallback
----------------------------------------------------------------------
local function fireProximityClaim(slot)
    for _, booth in ipairs(Workspace:WaitForChild("BoothInteractions"):GetChildren()) do
        if isRealBooth(booth) and booth:GetAttribute("BoothSlot") == slot then
            local prompt = booth:FindFirstChildOfClass("ProximityPrompt") or booth:FindFirstChild("Claim")
            if prompt then
                pcall(function() fireproximityprompt(prompt, 0) end)
                log("fireProximityClaim: fired prompt for slot "..tostring(slot))
                return true
            end
        end
    end
    return false
end

local function tryClaimSlot(slot)
    log("tryClaimSlot: attempting remote claim for slot "..tostring(slot))
    if RemotesModule and RemotesModule.Event then
        local ok, err = pcall(function()
            RemotesModule.Event("ClaimBooth"):InvokeServer(slot)
        end)
        if not ok then
            log("tryClaimSlot: remote claim error: " .. tostring(err))
        else
            log("tryClaimSlot: remote claim invoked (server-side may take a moment to reflect)")
        end
    else
        log("tryClaimSlot: RemotesModule missing or invalid - skipping remote claim")
    end

    task.wait(0.8)
    -- fallback to proximity
    pcall(function()
        fireProximityClaim(slot)
    end)
end

local function claimFlow()
    log("claimFlow: start")
    local candidates = findUnclaimedNearby(92)
    if #candidates == 0 then candidates = findUnclaimedNearby(9999) end
    if #candidates == 0 then
        log("claimFlow: no candidates found")
        return false
    end

    for _, slot in ipairs(candidates) do
        log("claimFlow: trying slot "..tostring(slot))
        tryClaimSlot(slot)
        task.wait(0.7)
        -- verify ownership via UI
        local ui = BoothUI:FindFirstChild("BoothUI"..tostring(slot))
        if ui and ui.Details and ui.Details.Owner and tostring(ui.Details.Owner.Text):lower():find(LocalPlayer.DisplayName:lower()) then
            log("claimFlow: ownership verified for slot "..tostring(slot))
            -- teleport to booth part
            for _, booth in ipairs(Workspace.BoothInteractions:GetChildren()) do
                if isRealBooth(booth) and booth:GetAttribute("BoothSlot") == slot then
                    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
                    local hrp = char:WaitForChild("HumanoidRootPart")
                    hrp.CFrame = booth.CFrame * CFrame.new(3,3,3)
                    task.wait(0.12)
                    -- face forward (north)
                    hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + Vector3.new(0,0,-1))
                    log("claimFlow: teleported and faced forward at slot "..tostring(slot))
                    -- start dance 1
                    pcall(function()
                        if char:FindFirstChild("Animate") then
                            local hum = char:FindFirstChildOfClass("Humanoid")
                            if hum and char.Animate:FindFirstChild("dance") then
                                pcall(function() hum:LoadAnimation(char.Animate.dance.Animation1):Play() end)
                            end
                        end
                    end)
                    return true
                end
            end
            return true
        else
            log("claimFlow: claim did not stick for slot "..tostring(slot)..", trying next")
        end
    end

    log("claimFlow: exhausted candidates")
    return false
end

-- initial claim and respawn re-claim
task.spawn(function()
    task.wait(1.2)
    claimFlow()
end)
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(2)
    claimFlow()
end)

----------------------------------------------------------------------
-- THEMED BOOTH TEXT (filter=false to stop ######)
----------------------------------------------------------------------
local function updateBoothText()
    local raised = raisedStat.Value or 0
    local goal = _G.goalAmount

    local themedText = string.format([[
<stroke thickness="5" color="#445094">
    <b><font color="#000000">GOAL: %s / %s</font></b>
</stroke>
]], tostring(raised), tostring(goal))

    if RemotesModule and RemotesModule.Event then
        local ok, err = pcall(function()
            RemotesModule.Event("SetCustomization"):FireServer({
                text = themedText,
                richText = true,
                filter = false,
                textFont = Enum.Font.FredokaOne,
                textColor = Color3.new(0,0,0),
                strokeColor = Color3.fromHex("#445094"),
                strokeOpacity = 1,
                buttonStrokeColor = Color3.new(0,0,0),
                buttonTextColor = Color3.new(0,0,0),
                buttonColor = Color3.fromRGB(255,255,255),
                buttonHoverColor = Color3.fromRGB(255,255,255),
                buttonLayout = ""
            }, "booth")
        end)
        if not ok then
            log("updateBoothText: SetCustomization failed: "..tostring(err))
        end
    else
        log("updateBoothText: RemotesModule unavailable")
    end
end

-- periodic board update
task.spawn(function()
    while task.wait(_G.boardUpdateInterval) do
        pcall(updateBoothText)
    end
end)

----------------------------------------------------------------------
-- DONATION JUMP (auto update text)
----------------------------------------------------------------------
local lastRaised = tonumber(raisedStat.Value) or 0
raisedStat.Changed:Connect(function(new)
    local newVal = tonumber(new) or 0
    if newVal > lastRaised then
        log("Donation detected: "..tostring(lastRaised).." -> "..tostring(newVal))
        task.spawn(function()
            local char = LocalPlayer.Character
            local hum = char and char:FindFirstChildOfClass("Humanoid")
            if hum then
                for i = 1, 3 do
                    hum:ChangeState(Enum.HumanoidStateType.Jumping)
                    task.wait(0.35)
                end
            end
        end)
        pcall(updateBoothText)
    end
    lastRaised = newVal
end)

----------------------------------------------------------------------
-- DANCE ROTATION (1 -> 2 -> 3 every 60s)
----------------------------------------------------------------------
task.spawn(function()
    log("Starting dance rotation")
    while true do
        local char = LocalPlayer.Character
        if char and char:FindFirstChildOfClass("Humanoid") and char:FindFirstChild("Animate") then
            log("Playing dance 1")
            pcall(function() char.Humanoid:LoadAnimation(char.Animate.dance.Animation1):Play() end)
        end
        task.wait(60)
        if char and char:FindFirstChildOfClass("Humanoid") and char:FindFirstChild("Animate") then
            log("Playing dance 2")
            pcall(function() char.Humanoid:LoadAnimation(char.Animate.dance2.Animation2):Play() end)
        end
        task.wait(60)
        if char and char:FindFirstChildOfClass("Humanoid") and char:FindFirstChild("Animate") then
            log("Playing dance 3")
            pcall(function() char.Humanoid:LoadAnimation(char.Animate.dance3.Animation3):Play() end)
        end
        task.wait(60)
    end
end)

----------------------------------------------------------------------
-- ROBUST SAY CHAT (tries multiple remotes & logs)
----------------------------------------------------------------------
local function sayChat(msg)
    if not msg then return end
    -- 1) Try DefaultChatSystemChatEvents -> SayMessageRequest
    local ok1, err1 = pcall(function()
        local ev = ReplicatedStorage:WaitForChild("DefaultChatSystemChatEvents", 5):WaitForChild("SayMessageRequest", 5)
        if ev then
            ev:FireServer(msg, "All")
            log("sayChat: Sent via DefaultChatSystemChatEvents: "..tostring(msg))
            return true
        end
    end)
    if ok1 then return true end

    -- 2) Try TextChatService RBXGeneral channel
    if TextChatService and TextChatService.TextChannels and TextChatService.TextChannels:FindFirstChild("RBXGeneral") then
        local ok2, err2 = pcall(function()
            TextChatService.TextChannels.RBXGeneral:SendAsync(msg)
            log("sayChat: Sent via TextChatService RBXGeneral: "..tostring(msg))
        end)
        if ok2 then return true end
    end

    -- 3) Last-resort: print failure
    log("sayChat: failed to send message. Err1="..tostring(err1))
    return false
end

----------------------------------------------------------------------
-- AUTO BEGGING (no emojis) - uses robust sayChat and logs
----------------------------------------------------------------------
task.spawn(function()
    log("Starting auto-begging loop")
    while true do
        local msg = _G.begMessages[math.random(1,#_G.begMessages)]
        log("Auto-begging: attempting to send -> "..msg)
        local sent = pcall(sayChat, msg)
        if not sent then
            log("Auto-begging: send call failed (pcall) for message: "..msg)
        end
        task.wait(_G.begInterval)
    end
end)

log("FINAL fixed script loaded.")
